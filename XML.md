При включването на документа “xpto.xml” с използване <xi:include href=”xpto.xml” parse=”text”/>, документът “xpto.xml” ще бъде включен:
-като обикновен текст
		
XML пространствата от имена се дефинират чрез атрибути и могат да бъдат специфицирани в кой да е XML елемент. 
-вярно

При използване на вътрешна и външна DTD дефиниция, вътрешната DTD може да предефинира:
-само ENTITY i ATTLIST на външната дефиниция

В XSchema, референцията към тип може да реферира:
-само към глобални типове

В примера по-долу:
<x xmlns:n1="http://www.hayde-de.org"xmlns="http://www.hayde-de.org" >
 <ok a="1" b="2" />
	<hmmm a="1" n1:a="2" /> 
</x>
-Дефиницията на елемента <hmmm> е валидна според спецификацията на пространствата от имена.

Приложения, които имат нужда от сложни структурни манипулации на много от XML елементите, трябва да използват:
-DOM

При избиране на елемент, наречен MyElem и имащ атрибут Attr със стойност title, в XSLT ние трябва да използваме:
-select=”MyElem[@Attr=’title’]”

Атрибутите, специфицирани в DTD посредством ключовата дума IMPLIED:
-могат да бъдат определени (специфицирани) в XML

Binary entity може да се използва само като атрибут от тип ENTITY
-вярно

В XML Schema, ние можем да построим производни (derived) types
-както с extensions, така и с restrictions

В CSS3, абсолютната (absolute) схема за позициониране:
-се характеризира със задаване на явно отместване (explicit offset) спрямо съдържащия блок

Разгледайте имената на XML празните елементи <emptyTag /> и <emptyTag/ >
-първият е валиден, вторият е невалиден

xml:id е псевдо-атрибут, който задава условие за уникална стойност, като това:
-не е необходимо да се декларира в DTD или XML схема

В XSchema, глобалните типове:
-винаги са директни наследници на корена

DocumentType::Node Interface се използва за получаване на информация за документ, описан в DTD.
-DOM 1.0 не разрешава редактиране на този възел

Ако няма специфицирано кодиране за един XML документ и документът не е нито в UTF-8, нито в UTF-16, тогава резултатът е:
-ERROR

XPath изразът //book[@pages] връща:
-всички book елементи, които имат атрибут pages

XLink не може да дефинира фрагментни идентификатори за URI, сочещи към възли или части от тях в XML ресурси.
-вярно

Една XLink дъга (arc), която има локален стартов ресурс и отдалечен краен ресурс, се нарича:
-outbound

Единственото изискване на един XML документ да бъде валиден е този документ да е структуриран (формиран) съгласно правилата за XML синтаксиса.
-невярно

Кой от отговорите по-долу не съдържа име на RDFS свойство:
-rdfs:subRange

rdf:seq задава:
-група на подредени ресурси или литерали, с вероятно дублиране

“Формална, експлицитна спецификация на споделена концептуализация” е дефиниция за:
-нещо друго, което не присъства в тези отговори

Resource Description Framework (RDF) представя информация за ресурци, които:
-могат да бъдат или да не бъдат достъпни в Уеб

RDF Literals могат да бъдат зададени само като обект в RDF-тройка
-вярно

Йерархичната подредба на понятия заедно с информация за допълнителни отношения като по-широко/по-тясно понятие, синоними, еквивалентност и др., задава:
-Тезаурус

Annotation Property в OWL се използва за добавяне на метаданни:
-към класове, екземпляри и свойства

В OWL, също както и в ООП, не може да съществуват два класа с общи екземпляри.
-невярно

Ако свойството P е дефинирано с обхват (range) C и ресурсът R е обект в тройка с предикат P, то следва, че:
-R rdf:type C

В RDF, група от алтернативни стойности се задава чрез:
-<rdf:Alt>

В RDFS, Property е подмножество на RDFS Resources и има за домейн (rdfs:domain):
-класа, асоцииран с това Property

Могат ли екземплярите на класовете да бъдат част от онтологията, описваща тези класове?
-да

Описанието 
ex:adrian foaf:knows ex:gerd
ex:adrian foaf:age “41”^^xs:int.
представя RDF Triples в:
-N3 формат

Методът getAttributes() на DOM интерфейса Node връща:
-NamedNodeMap

Resource Description Framework (RDF) служи за описания, предназначени:
-за обработка от софтуерни приложения

rdf:Bag задава:
-група на неподредени ресурси или литерали, с вероятно дублиране

Целта на валидацията на XML документ от XML парсера е да се провери дали XML документът е добре структуриран (well-formed)
-невярно

За постигане на по-малък, ефикасен и бърз код с използване на StAX, се препоръчва:
-cursor API

Редът <!ATTLIST point honorific (Mr|Ms|Mrs|Rev|Dr) … > е валиден DTD пример за:
-name group

В XML схема, уникалността на key и keyref елементите е:
-само за йерархията на съответните елементи в документа-екземпляр, за които са дефинирани key и keyref

Ако сме дефинирали XSL променлива като <xsl:variable name=”price”>low</xsl:variable>, то тя може да се използва в XSL елемент като:
-<xsl:value-of-select=”$price”/>

MEDIA атрибутите като screen, aural, braille, tty, и т.н., са част от:
-CSS2 и CSS3 спецификациите

В XLink информацията за това как се преминава през двойка ресурси (напр. посока на преминаване и за поведение при преминаването), се нарича:
-дъга

При парсване на XML документи посредством StAX, можем да се придвижваме само напред в XML документа.
-истина

Чрез XPointer можем да реферираме към повече от един елемента в XML документ.
-вярно

В XSchema, типът на всеки елемент на еквивалентен клас трябва да бъде:
-същият като типа на елемента-екземплят, или негов дериват

Ако в XSchema дефинираме exact тип, то:
-той може да има дериватни типове, но те не могат да бъдат използвани в XML документа вместо този exact тип

С един DOM Element обект:
-не може да направите разлика между подразбираща се (default) стойност, определена в DTD, и стойността, дадена в XML файла

Общо текстово Entity:
-не може да бъде използвано рекурсивно, но може да се появи в съдържанието на елемент и/или в стойност на атрибут

Кой от елементите ISBN по-долу не се описва от дефиницията <element name=”ISBN” type=”cat:ISBNType”/>, където ISBNType е:
<datatype name=”ISBNType” source=”string”>
<pattern value=”\d{5}-\{5}-\d{5}”/>
<pattern value=”\d{1}-\{3}-\d{5}-\d{1}”/>
<pattern value=”\d{1}-\{2}-\d{6}-\d{1}”/>
</datatype>
-6-32-47843-5

Какво не е възможно да бъде описано в DTD:
-минимален и максимален брой срещания на елемент

Кой от следните елементи не е с грешен XML синтаксис:
-<birth>28.04.1990, Gabrovo</birth>

Речник с документиран процес за актуализация се нарича:
-контролиран

Person, title, familyName, knows, age, Document и Organization са име на елементи, дефинирани от:
-FOAF

Всеки два OWL класа принципно могат да се препокриват, т.е. да имат общи екземпляри.
-вярно

creator, title, publisher, contributor, date и format са име на елементи, дефинирани от:
-DC

Описанието в RDF на група, съдържаща само зададените в описанието членове, става чрез използване на:
-колекция

Кой от отговорите по-долу не съдържа име на RDFS клас:
-rdfs:Property

Квалифицирано XML име (наречено QName) e:
-име от вида namespace_prefix:local_name

Ако даден атрибут на XML елемент има само локално име (т.е. името му не е QName), то:
-той се отнася неявно към пространството от имена на елемента, към който принадлежи

Разгледайте имената на XML елементите <xml-tag> and <tag-xml>. Те са:
-първият е невалиден, вторият е валиден

Един XML документ може да има повече от едно DTD:
-Вярно

Даден CSS стил може да бъде inlined (а не embedded) в документ посредством:
-атрибута STYLE

Кой от следните изрази е валиден пример за дефиниране на избор (choice) от елементи в DTD:
- (A |B |C)

Всяко IDREF, декларирано в DTD, трябва да:
-избере дадено определено ID

В SAX, приложните обекти имащи достъп до XML сорса:
-Трябва да бъдат регистрирани ( от програмиста ) за callback функциие на парсера

Изберете верното:
-Един URI може да бъде или URL, или URN

В RDFS, Property e подмножество на RDFS Resources и има за обхват(rdfs:range):
-Класа, асоцииран с това Property

За представяне на стойности в XML файлове, ние можем да използваме XML атрибути или XML елементи. Кой от следващите отговори не е аргумент за употреба на атрибути вместо на елементи?
-Използваме атрибути за валидация на сложна структура

XML Schema разрешава да се прави разлика между уникална стойност (unique) и ключ (key):
-Вярно

Кое от твърденията е истина:
-Само DOM Element обектите имат атриут

SAX Element обектите:
-Могат да разграничават атрибутите, дефинирани изрично от тези специфицирани в DTD

Уникална идентификация на пространство от имена се реализира с:
-URL

Ако свойство P е за субекта S, който участва в RDF тройката SPO и имаме P rdfs:domain C, то следва, че:
-S rdf:type C

Регулярният израз [^0-9]x дефинира XSchema стрингови стойности, които представляват:
-Който и да е не-цифров символ следван от символа x

Кой от следните изрази е валиден пример за дефиниране на последователност (sequence) от елементи в DTD:
-(A, B, C)

Регулярният израз [1-9]?[0-9] дефинира в XSchema стрингови стойности, които са:
-От 0 до 99

XML пространствата от имена се използват за разграничаване:
-И на XML елементи, и на XML атрибути

Разгледайте <xsl:value-of> елемента. Ако стойността на неговия select атрибут е select=’.’, то тогава ние избираме:
-Текстовия контекст на елемета и текстовия контекст на всички наследници на елемента

В XSchema, локалните типове:
-Не могат да бъдат директни наследници на корена

Един XML документ може да има повече от едно вътрешно DTD.
-Невярно

При използване на XPath text() функцията ние избираме:
-Текстовия контекст само на елемента

CDATA съдържанията са:
-Игнорирани от XML парсерите

В CSS3, фиксираната (fixed) схема за позициониране:
-Предизвиква повторение на кутията на всяка страница при paged media

В XLink, изходящите връзки (outbound links) могат да имат:
-Точно два участващи в тях ресурса

XSL елементът Apply-Templates се използва вътре в един шаблон (template) за извикване на други шаблони. Той:
-Активира рекурсивно обработката на всички наследници на елемента, за който се отнася

В XLink, входящите дъги (inbound arcs) могат да имат:
-Произволен краен брой участващи в тях ресурси

Всеки DOM възел (Node) може да има деца
-Вярно

XSchema шаблонен фасет (pattern facet) е фасет за данни от тип:
-string

Осъществяването на emedding (а не inlining) на Style Sheet според CSS правилата е възможно посредством:
-елемента STYLE

Параметрично Entity:
-се дефинира в маркъп декларациите в DTD и може да се ползва само в DTD дефиниции

XSL се използва за:
-трансформиране на XML документ към друг текстов документ

Най-общо маркъп езиците включват:
-структурни (layout), функционални (action), семантични (meaning) и стилистични (appearance) описания

Символите <, > и ‘ са валидни PCDATA символи.
-Невярно

XML документите могат да съдържат само един елемент-корен
-Вярно

XPath изразът ./book[author/last = “пробен изпит”] връща:
-елемент book – наследник на текущия елемент, който има елемент auhor с поделемент last равен на “пробен изпит”

XML йерархията <a> <b> <c> </b> </c> </a> e:
-некоректна

Следният XML документ е добре конструиран (well-formed):
<?xml version=’1.0’?>
<!—http://www.w3.org is bound to both ref1 and default namespace- ->
<myDoc xmlns:ref1=”http://www.w3.org”
xmlns= “http://www.w3.org”
xmlns:ref2=”http://www.hmmm.bg”>
  <myElem a=”1” b=”2” />
  <myElem a=”1” refl:a=”2”/>
  <myElem refl1:a=”1” ref2:a=”2”/>
</myDoc>
-Истина

XML пространството от имена се отнася:
-Само за йерархията от елементи, за която е дефинирано

Eлементите key/keyref задават уникалност в XML Schema с обхват:
-Само за тези елементи в документа-екземпляр, за които са декларирани key/keyref

Изберете верния отговор:
-Всеки валиден XML документ е добре конструиран, но обратното не е задължително вярно
Изпълнението на XSLT декларациите
<xsl:value-of select=”.”/>
И
<xsl:value-of select=”text()”/>
Води:
-До един и същ или до различни резултати в зависимост от типа на съдържанието на текущия елемент

При прилагане на XSLT трансформацията
<xsl:template match=”name”>
  <xsl:element name=”{.}”>
    Very nice!
  </xsl:element>
</xsl:template>
За документа
<names>
  <name>Bob</name>
  <name>Steve</name>
</names>
Имената на създадените елементи в резултантното дърво ще бъдат:
-Със съдържанието на елементите в изходящото дърво

Елементите от прост тип в една XML Schema са от даден предефиниран тип и:
-Не могат да имат атрибути и под-елементи

Параметричните единици (Parameter Entities) са декларирани в DTD и се използват:
-Единствено в декларациите на DTD

За осигуряване на уникалността на префиксите, означаващи пространства от имена се използва:
-Само URL

Разгледайте P:first-letter { font-size:200% }. Това е:
-Псевдо-елемент (pseudo-element)

Атрибутите на XML са чувствителни към регистъра.
-Вярно

Редът <!ATTLIST point honorific (Mr|Ms|Mrs|Rev|Dr) … > е валиден DTD пример за:
-name group

DTD валидацията ограничава елементите и атрибутите, които могат да участват в документа, само по техните локални имена, ако в DTD дефиницията на елемента или атрибута той е участвал с локално име вместо с QName.
-Вярно

Описанието (конкретизацията) на RDF твърдение чрез използване на RDF речника се нарича:
-Reification

В RDF един екземпляр може да има няколко типа (т.е. да участва като субект в няколко релации rdf:type).
-Вярно

В какъв формат е следният запис:
<http://www.w3.org/TR/rdf-syntax-grammar> <http://xml.org/1.1/title> "XML Basics" .
<http://www.w3.org/TR/rdf-syntax-grammar> <http://example.org/stuff/xml> _:bnode .
_:bnode <http://example.org/stuff/1.0/fullname> "D. D. Vass" .
_:bnode <http://example.org/stuff/1.0/homePage> <http://www.aemon.net/> .
-Друг формат, различен от останалите 

XLink не може да дефинира фрагментни идентификатори за URI, сочещи към възли или части от тях в XML ресурси.
-Вярно

RDF твърдението 
dbpedia:Mount_Etna rdf:type my-pref:Mountain, my-pref:Volcano .
е допустимо и валидно
-Вярно

Множественото наследяване (multiple inheritance) не е допустимо в RDFS.
-Невярно

В RDF, класовете могат да бъдат екземпляри на други класове.
-Вярно

Ако имаме дефинирани две еднакви CSS свойства с различни стойности за един и същи елемент, то ще се приложи последното дефинирано свойство:
-Винаги, освен когато едно от свойствата е по-специфично

Изберете едно:
-SAX използва push парсване, а StAX – парсване от тип pull

SAX служи както за четене на XML документи, така и за генериране на XML
-Невярно

XMLReader в SAX 2.0 разширява стандартния Java Reader интерфейс.
-Невярно

Атрибутът xml:base задава:
-База за относителни URI връзки към външни за документа ресурси

Всички членове на подклас OWL са членове на супер-класовете на този клас.
-Вярно

За разлика от SAX, при използването на StAX можем да се движим както напред, така и назад в XML документа.
-Невярно

Кое не е цел на RDFа:
-Намаляване на разликата между интерпретацията на Уеб страниците от потребителя и програмите

Литералите в RDF трайките могат да бъдат:
-Всеки от останалите отговори е грешен

Отдалечените XLink ресурси винаги представляват външни за документа ресурси.
-Невярно

DOMException връща HEIRARCHY_REQUEST_ERR при опит за:
-Вмъкване на възел на непоходящо място в йерархията на DOM дървото

Събитието processingInstruction възниква, когато SAX парсерът достигне до всяка една инструкция за обработка, включително и до XML декларацията.
-Невярно

Кой от следните типове не се среща в описанието на разширена връзка в XLink
-edge

В XSLT, взимането на решение кои елементи ще бъдат обработени се задава със следния XSLT елемент:
-<xsl:apply-templates>

В CSS, задаването на елемент, чийто атрибут attr има стойност, съдържаща на произволно място в себе си стойността xpto, става чрез:
-[attr~=xpto]

В XSchema, за глобалните типове:
-minOccurs и maxOccurs може да се дефинират само за глобални типове, които се реферират

Задаването на мрежа от хора чрез FOAF твърдения става посредством релацията:
-foaf:knows

“other” и “none” са възможни стойности за XLink атрибутите:
-actuate и show

creator e:
-един от основните 15 елемента от DC Metadata

Какво не е възможно да бъде описано в DTD
-минимален и максимален брой срещания на елемент

При използване на вътрешна и външна DTD дефиниция, вътрещната DTD може да предефинира:
-само ENTITY и ATTLIST на външната дефиниция

Свойството rdfs:member е супер-свойство на всички свойства, които са екземпляри на:
-rdfs:ContainerMembershipProperty

Как можем да потиснем запазването на допълнителни (следващи един след друг) празни интервали в съдържанието на текстови елемент?
-Посредством използване на друг псевдо-атрибут, различен от изброените в останалите отговори на въпроса

В RDF твърдението
S rdf:type O
-O задава клас (категория), а S задава екземпляр на този клас
